AWSTemplateFormatVersion: 2010-09-09
Parameters:
  AwsRegion:
    Type: String
    Description: Please enter the region in which the lambda will be executed
    Default : us-east-1
    AllowedValues:
      - us-east-1
      - us-east-2	
      - us-east-1	
      - us-west-1	
      - us-west-2
      - af-south-1
      - ap-east-1
      - ap-southeast-3
      - ap-south-1
      - ap-northeast-3
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-northeast-1
      - ca-central-1
      - eu-central-1
      - eu-west-1
      - eu-west-2
      - eu-south-1
      - eu-west-3
      - eu-north-1
      - me-south-1
      - me-central-1
      - sa-east-1

  ApiKey:
    Type: String
    NoEcho: "true"
    Description: Please enter your Cloud One API Key
  EmailSender:
    Type: String
    Description: Email address to be used for sending report
  EmailRecipients:
    Type: String
    Description: Comma separated (without spaces) email addresses for recieving report
  CronSchedule:
    Type: String
    Description: Schedule the time you would like the lambda function to run in the cron format (Default is every wednesday)
    Default: cron(0 12 ? * WED *)
  CloudOneRegion:
    Type: String
    Description: Enter your Cloud One Region
    Default: us-1
    AllowedValues:
      - trend-us-1
      - us-1
      - in-1
      - gb-1
      - jp-1
      - de-1
      - au-1
      - ca-1
      - sg-1
Resources:
  PythonPackageLayer:
    Type: "AWS::Lambda::LayerVersion"
    Properties:
      CompatibleRuntimes:
        - python3.9
      Content:
        S3Bucket: vulnerabilitytestbucket # Replace "vulnerabilitytestbucket" by the name of your bucket where you upload the zip file
        S3Key: "DeepSecurityPackageLayer.zip" 
      LayerName: "DSlayer"
  LambdaRole: 
    Type: "AWS::IAM::Role"
    Properties: 
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          - Effect: "Allow"
            Principal: 
              Service: 
                - "lambda.amazonaws.com" 
            Action: 
              - "sts:AssumeRole"  
      ManagedPolicyArns:
          - arn:aws:iam::aws:policy/AmazonVPCCrossAccountNetworkInterfaceOperations
          - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          - arn:aws:iam::aws:policy/AmazonInspector2ReadOnlyAccess
          - arn:aws:iam::aws:policy/CloudWatchLambdaInsightsExecutionRolePolicy
          - !Ref LambdaSESWritePolicy
          - !Ref LambdaInvokePolicy
          - !Ref LambdaSecretAcessPolicy

  LambdaInvokePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: VisualEditor0
          Effect: Allow
          Action:
          - lambda:InvokeFunction
          - lambda:InvokeAsync
          Resource: !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:*

  LambdaSESWritePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: VisualEditor0
          Effect: Allow
          Action:
          - ses:CreateReceiptRule
          - ses:UpdateConfigurationSetEventDestination
          - ses:SetIdentityMailFromDomain
          - ses:DeleteReceiptFilter
          - ses:VerifyEmailIdentity
          - ses:DeleteCustomVerificationEmailTemplate
          - ses:TestRenderTemplate
          - ses:CreateReceiptFilter
          - ses:DeleteReceiptRule
          - ses:DeleteConfigurationSet
          - ses:CreateConfigurationSetTrackingOptions
          - ses:UpdateAccountSendingEnabled
          - ses:DeleteConfigurationSetEventDestination
          - ses:VerifyDomainDkim
          - ses:DeleteVerifiedEmailAddress
          - ses:VerifyDomainIdentity
          - ses:CloneReceiptRuleSet
          - ses:SetIdentityHeadersInNotificationsEnabled
          - ses:SendEmail
          - ses:SendTemplatedEmail
          - ses:SendCustomVerificationEmail
          - ses:UpdateTemplate
          - ses:DeleteConfigurationSetTrackingOptions
          - ses:UpdateConfigurationSetTrackingOptions
          - ses:SetIdentityNotificationTopic
          - ses:SetIdentityDkimEnabled
          - ses:PutConfigurationSetDeliveryOptions
          - ses:VerifyEmailAddress
          - ses:UpdateReceiptRule
          - ses:CreateConfigurationSet
          - ses:UpdateConfigurationSetReputationMetricsEnabled
          - ses:DeleteReceiptRuleSet
          - ses:CreateTemplate
          - ses:SendRawEmail
          - ses:ReorderReceiptRuleSet
          - ses:SendBounce
          - ses:UpdateConfigurationSetSendingEnabled
          - ses:SetActiveReceiptRuleSet
          - ses:CreateCustomVerificationEmailTemplate
          - ses:UpdateCustomVerificationEmailTemplate
          - ses:DeleteTemplate
          - ses:CreateReceiptRuleSet
          - ses:SetReceiptRulePosition
          - ses:CreateConfigurationSetEventDestination
          - ses:SendBulkTemplatedEmail
          - ses:DeleteIdentity
          - ses:SetIdentityFeedbackForwardingEnabled
          Resource: "*"

  LambdaSecretAcessPolicy: 
    Type: AWS::IAM::ManagedPolicy
    Properties:
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: VisualEditor0
          Effect: Allow
          Action:
          - "secretsmanager:GetSecretValue"
          - "secretsmanager:DescribeSecret"
          - "sts:AssumeRole"
          Resource: !Ref ApiKeySecret

  #   This secret holds the Trend Micro Cloud One API key.
  ApiKeySecret:
    Type: AWS::SecretsManager::Secret
    Properties:
      Name: "TrendMicro/CloudOne/ApiKey"
      SecretString: !Sub |
        {
          "ApiKey": "${ApiKey}"
        }
  LambdaLayerParameter:
    Type: AWS::SSM::Parameter
    Properties:
      Name: lambda_layer_for_vulnerability
      Type: String
      Value: "NA"

  VulnerabilityReportLambda:
    Type: "AWS::Lambda::Function"
    DependsOn:
      - "LambdaLayerParameter"
    Properties:
      Environment:
        Variables:
          awsregion: !Ref AwsRegion
          c1_api: !Ref ApiKeySecret
          sender: !Ref EmailSender
          recipients: !Ref EmailRecipients
          cloudoneregion: !Ref CloudOneRegion
      Code:
        ZipFile: |
            from __future__ import print_function
            import os
            import json
            import csv
            import sys, warnings
            import boto3
            from botocore.exceptions import ClientError
            from datetime import datetime
            from pprint import pprint

            from typing import List
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            from email.mime.application import MIMEApplication
            from tempfile import TemporaryFile

            import deepsecurity as ds
            from deepsecurity.models.intrusion_prevention_rule import IntrusionPreventionRule
            from deepsecurity.models.intrusion_prevention_rules import IntrusionPreventionRules
            from deepsecurity.rest import ApiException
                

            API_VERSION = "v1"
            AWS_REGION = os.environ.get('awsregion')
            SENDER = os.environ.get('sender')
            RECIPIENTS = os.environ.get('recipients')
            HOST = f"https://workload.{os.environ.get('cloudoneregion')}.cloudone.trendmicro.com/api"
            C1_API_KEY = os.environ.get("c1_api")

            def cves_from_instance(instance_id, inspector):
                cves = list()
                result = list()
                print('<<<<<<< checking instance id:', instance_id)
                resp = inspector.list_findings(
                    filterCriteria={
                        "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                        "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                    }
                )
                result.extend(resp["findings"])
                next_token = resp.get("nextToken")
                while next_token:
                    resp = inspector.list_findings(
                        filterCriteria={
                            "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                            "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                        },
                        nextToken=next_token,
                    )
                    result.extend(resp["findings"])
                    next_token = resp.get("nextToken")

                for finding in result:
                    cve = finding.get("packageVulnerabilityDetails", {}).get("vulnerabilityId")
                    if cve:
                        cves.append(cve)
                    # print(cve)
                return cves


            def all_instances_details_from_inspector(inspector):
                instances = list()
                result = list()
                findings = inspector.list_finding_aggregations(
                    aggregationType="AWS_EC2_INSTANCE",
                    # aggregationRequest='AWS_EC2_INSTANCE',
                )
                result.extend(findings["responses"])
                next_token = findings.get('nextToken')
                while next_token:
                    findings = inspector.list_finding_aggregations(
                        aggregationType="AWS_EC2_INSTANCE",
                        # aggregationRequest='AWS_EC2_INSTANCE',
                        nextToken=next_token,
                    )
                    result.extend(findings["responses"])
                    next_token = findings.get('nextToken')

                for finding in result:
                    instance_details = {
                        "id": finding["ec2InstanceAggregation"]["instanceId"],
                        "name": finding["ec2InstanceAggregation"].get("instanceTags", {}).get("Name"),
                    }
                    instances.append(instance_details)
                print("Found total instances =", len(instances))
                return instances


            def ds_config_and_version(cloud_one_api_key):
                # Setup
                if not sys.warnoptions:
                    warnings.simplefilter("ignore")
                API_VERSION = "v1"
                conf = ds.Configuration()
                conf.host = HOST
                conf.api_key["Authorization"] = f"ApiKey {cloud_one_api_key}"
                return conf, API_VERSION


            def send_email(sender, recipients, subject, html_body, attachment_details):
                print("sending email ...")

                # Create a new SES resource and specify a region.
                client = boto3.client("ses", region_name=AWS_REGION)

                msg = MIMEMultipart()
                text_part = MIMEText(html_body, _subtype="html")
                msg.attach(text_part)

                
                msg["To"] = recipients
                msg["From"] = sender
                msg["Subject"] = subject

                for item in attachment_details:
                    filename = item["filename"]
                    attachment = item["attachment"]

                    part = MIMEApplication(attachment.read(), filename)
                    part.add_header("Content-Disposition", "attachment", filename=filename)
                    msg.attach(part)

                client.send_raw_email(RawMessage={"Data": msg.as_bytes()})


            def lambda_handler(event, context):
                # get secret
                secrets = boto3.client('secretsmanager').get_secret_value(SecretId=C1_API_KEY)
                sm_data = json.loads(secrets["SecretString"])
                new_api_format = sm_data["ApiKey"]
                conf, api_version = ds_config_and_version(new_api_format)

                csv_rows = list()
                inspector = boto3.client("inspector2")
                all_instance_details = all_instances_details_from_inspector(inspector)
                for instance_details in all_instance_details:
                    instance_id = instance_details["id"]
                    instance_name = instance_details["name"]

                    print(instance_name, instance_id)
                    cves = cves_from_instance(instance_id, inspector)
                    print("inspector", cves)

                    search_criteria = ds.SearchCriteria()
                    search_criteria.field_name = "ec2VirtualMachineSummary/instanceID"
                    search_criteria.string_test = "equal"
                    search_criteria.string_value = instance_id

                    # Create a search filter with maximum returned items
                    search_filter = ds.SearchFilter()
                    search_filter.search_criteria = [search_criteria]

                    expand = ds.Expand(ds.Expand.intrusion_prevention)
                    expand.add(ds.Expand.ec2_virtual_machine_summary)

                    # Perform the search and do work on the results
                    computers_api = ds.ComputersApi(ds.ApiClient(conf))
                    rows = []

                    computers = computers_api.search_computers(
                        api_version,
                        search_filter=search_filter,
                        expand=expand.list(),
                        overrides=False,
                    )
                    num_found = len(computers.computers)

                    if num_found == 0:
                        print(f"No computers found for instance id: {instance_id}")

                    for computer in computers.computers:
                        # print('ips', computer.intrusion_prevention)
                        # print(computer.host_name)
                        print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   id", computer.id)
                        if computer.intrusion_prevention.rule_ids:
                            for ipr_id in computer.intrusion_prevention.rule_ids:
                                print(">>>>>>>>> checking rule id:", ipr_id)
                                api_client = ds.ApiClient(configuration=conf)
                                api = ds.ComputerIntrusionPreventionRuleDetailsApi(api_client)
                                ipr = api.describe_intrusion_prevention_rule_on_computer(
                                    computer_id=computer.id,
                                    intrusion_prevention_rule_id=ipr_id,
                                    api_version=api_version,
                                )
                                if ipr.cve:
                                    for cve in ipr.cve:
                                        if cve in cves:
                                            print(
                                                instance_id,
                                                computer.display_name,
                                                ipr.identifier,
                                                ipr.name,
                                                cve,
                                                ipr.severity,
                                                ipr.cvss_score,
                                            )
                                            csv_rows.append(
                                                [
                                                    instance_id,
                                                    computer.display_name,
                                                    ipr.identifier,
                                                    ipr.name,
                                                    cve,
                                                    ipr.severity,
                                                    ipr.cvss_score,
                                                ]
                                            )

                csv_file = TemporaryFile(mode="w+", newline="")
                writer = csv.writer(csv_file)
                csv_header_protected_instances = [
                    "instance_id",
                    "computer",
                    "ipr identifier",
                    "ipr name",
                    "cve",
                    "severity",
                    "cvss_score",
                ]
                writer.writerow(csv_header_protected_instances)
                for row in csv_rows:
                    writer.writerow(row)
                csv_file.seek(0)

                # The subject line for the email.
                subject = "Vulnrebility Report (CVEs) from Intrusion Prevention"

                protected_instances_html = '<table border="1">' + "\n"
                # write headers
                protected_instances_html += "</tr>" + "\n"
                for col in csv_header_protected_instances:
                    protected_instances_html += f"<th>{col}</th>" + "\n"
                protected_instances_html += "</tr>" + "\n"
                # write rows
                for row in csv_rows:
                    protected_instances_html += "<tr>" + "\n"
                    for col in row:
                        protected_instances_html += f"<td>{col}</td>" + "\n"
                    protected_instances_html += "</tr>" + "\n"
                protected_instances_html += "</table>"

                csv_rows_unprotected_instances = list()
                all_instance_details = all_instances_details_from_inspector(inspector)
                for instance_details in all_instance_details:
                    id = instance_details["id"]
                    name = instance_details["name"]
                    cves = cves_from_instance(id, inspector)
                    if cves:
                        for cve in cves:
                            csv_rows_unprotected_instances.append([id, name, cve])

                tmp_csv_file_unprotected_instances = TemporaryFile(mode="w+", newline="")
                writer = csv.writer(tmp_csv_file_unprotected_instances)
                csv_header_unprotected_instances = ["instance_id", "name", "cve"]
                writer.writerow(csv_header_unprotected_instances)
                for row in csv_rows_unprotected_instances:
                    writer.writerow(row)
                tmp_csv_file_unprotected_instances.seek(0)

                unprotected_instances_html = '<table border="1">' + "\n"
                # write headers
                unprotected_instances_html += "</tr>" + "\n"
                for col in csv_header_unprotected_instances:
                    unprotected_instances_html += f"<th>{col}</th>" + "\n"
                unprotected_instances_html += "</tr>" + "\n"
                # write rows
                for row in csv_rows_unprotected_instances:
                    unprotected_instances_html += "<tr>" + "\n"
                    for col in row:
                        unprotected_instances_html += f"<td>{col}</td>" + "\n"
                    unprotected_instances_html += "</tr>" + "\n"
                unprotected_instances_html += "</table>"


                # The HTML body of the email.
                body_html = f"""<html>
                <head></head>
                <body>
                    <h1>Protected Instances</h1>
                    {protected_instances_html}
                    <h1>Unprotected Instances</h1>
                    {unprotected_instances_html}
                </body>
                </html>
                """

                send_email(
                    SENDER,
                    RECIPIENTS,
                    subject,
                    body_html,
                    [{"filename": "protected_instances.csv", "attachment": csv_file},
                    {
                        "filename": "unprotected_instances.csv",
                        "attachment": tmp_csv_file_unprotected_instances,
                    }],
                )

      FunctionName: "vulnerability_report_lambda"
      Handler: "index.lambda_handler"
      Layers:
        - !Ref PythonPackageLayer
      Runtime: python3.9
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn

  AutoAssignIpsRuleLambda:
    Type: "AWS::Lambda::Function"
    DependsOn:
      - "LambdaLayerParameter"
    Properties:
      Environment:
        Variables:
          region: !Ref AwsRegion
          c1_api: !Ref ApiKeySecret
          sender: !Ref EmailSender
          recipients: !Ref EmailRecipients
          cloudoneregion: !Ref CloudOneRegion
          vulnerability_report_lambda_function_name: vulnerability_report_lambda
      Code:
        ZipFile: |
            import sys, warnings
            import json
            from typing import List
            from pprint import pprint
            import boto3
            from botocore.exceptions import ClientError
            import os
            import deepsecurity as ds
            from deepsecurity.rest import ApiException
            from deepsecurity.models.intrusion_prevention_rule import IntrusionPreventionRule
            from deepsecurity.models.intrusion_prevention_rules import IntrusionPreventionRules
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            from email.mime.application import MIMEApplication

            API_VERSION = "v1"
            AWS_REGION = os.environ.get("region")
            SENDER = os.environ.get("sender")
            RECIPIENTS = os.environ.get("recipients")
            HOST = f"https://workload.{os.environ.get('cloudoneregion')}.cloudone.trendmicro.com/api"
            C1_API_KEY = os.environ.get("c1_api")
            VULNERABILITY_REPORT_LAMBDA_FUNCTION = os.getenv("vulnerability_report_lambda_function_name")


            def ds_config_and_version(cloud_one_api_key):
                # Setup
                if not sys.warnoptions:
                    warnings.simplefilter("ignore")
                API_VERSION = "v1"
                conf = ds.Configuration()
                conf.host = HOST
                conf.api_key["Authorization"] = f"ApiKey {cloud_one_api_key}"
                return conf, API_VERSION


            def list_all_ips_rules(conf, api_version) -> List[IntrusionPreventionRule]:
                api_client = ds.ApiClient(configuration=conf)
                all_ips_rules: List[IntrusionPreventionRule] = list()

                ips = ds.IntrusionPreventionRulesApi(api_client=api_client)

                search_criteria = ds.SearchCriteria(id_value=0, id_test="greater-than")
                search_filter = ds.SearchFilter(max_items=5000, search_criteria=[search_criteria])

                while True:
                    rules: IntrusionPreventionRules = ips.search_intrusion_prevention_rules(
                        api_version=api_version, search_filter=search_filter, async_req=False
                    )

                    ips_rules: List[IntrusionPreventionRule] = rules.intrusion_prevention_rules
                    if not ips_rules:
                        break

                    all_ips_rules.extend(ips_rules)
                    search_criteria.id_value = ips_rules[-1].id

                return all_ips_rules


            def computer_from_instance_id(configuration, api_version, instance_id):
                # Set search criteria
                search_criteria = ds.SearchCriteria()
                search_criteria.field_name = "ec2VirtualMachineSummary/instanceID"
                search_criteria.string_test = "equal"
                search_criteria.string_value = instance_id

                # Create a search filter with maximum returned items
                search_filter = ds.SearchFilter()
                search_filter.search_criteria = [search_criteria]

                expand = ds.Expand(ds.Expand.intrusion_prevention)
                expand.add(ds.Expand.ec2_virtual_machine_summary)

                # Perform the search and do work on the results
                computers_api = ds.ComputersApi(ds.ApiClient(configuration))

                computers = computers_api.search_computers(
                    api_version, search_filter=search_filter, expand=expand.list(), overrides=False
                )
                num_found = len(computers.computers)

                if num_found == 0:
                    print(f"No computers found for instance id: {instance_id}")

                for computer in computers.computers:
                    return computer


            # def vulnerabilities_from_instance(configuration, api_version, instance_id):
            def vulnerabilities_from_instance(
                configuration, api_version, instance_id, all_rules_dict
            ):
                # Set search criteria
                search_criteria = ds.SearchCriteria()
                search_criteria.field_name = "ec2VirtualMachineSummary/instanceID"
                search_criteria.string_test = "equal"
                search_criteria.string_value = instance_id

                # Create a search filter with maximum returned items
                search_filter = ds.SearchFilter()
                search_filter.search_criteria = [search_criteria]

                expand = ds.Expand(ds.Expand.intrusion_prevention)
                expand.add(ds.Expand.ec2_virtual_machine_summary)

                # Perform the search and do work on the results
                computers_api = ds.ComputersApi(ds.ApiClient(configuration))
                rows = []

                computers = computers_api.search_computers(
                    api_version, search_filter=search_filter, expand=expand.list(), overrides=False
                )
                num_found = len(computers.computers)

                if num_found == 0:
                    print(f"No computers found for instance id: {instance_id}")

                for computer in computers.computers:
                    # print('ips', computer.intrusion_prevention)
                    # print(computer.host_name)
                    print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   id", computer.id)
                    if computer.intrusion_prevention.rule_ids:
                        for ipr_id in computer.intrusion_prevention.rule_ids:
                            print(">>>>>>>>> checking rule id:", ipr_id)
                            cves = all_rules_dict.get(ipr_id)
                            if cves:
                                for cve in cves:
                                    rows.append(cve)

                    else:
                        print(f"instance has no ips - {instance_id}")
                return rows


            def add_rules_to_computer(configuration, api_version, computer_id, rule_ids):
                # Initialization
                # Set Any Required Values
                api_instance = ds.ComputerIntrusionPreventionRuleAssignmentsRecommendationsApi(
                    ds.ApiClient(configuration)
                )
                intrusion_prevention_rule_ids = ds.RuleIDs(rule_ids=rule_ids)
                overrides = False

                try:
                    api_response = api_instance.add_intrusion_prevention_rule_ids_to_computer(
                        computer_id,
                        api_version,
                        intrusion_prevention_rule_ids=intrusion_prevention_rule_ids,
                        overrides=overrides,
                    )
                    pprint(api_response)
                except ApiException as e:
                    print(
                        "An exception occurred when calling ComputerIntrusionPreventionRuleAssignmentsRecommendationsApi.add_intrusion_prevention_rule_ids_to_computer: %s\n"
                        % e
                    )


            def cves_from_instance(instance_id, inspector):
                cves = list()
                result = list()
                # print('instance', instance_id)
                resp = inspector.list_findings(
                    filterCriteria={
                        "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                        "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                    }
                )
                result.extend(resp["findings"])
                next_token = resp.get("nextToken")
                while next_token:
                    resp = inspector.list_findings(
                        filterCriteria={
                            "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                            "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                        },
                        nextToken=next_token,
                    )
                    result.extend(resp["findings"])
                    next_token = resp.get("nextToken")

                for finding in result:
                    cve = finding.get("packageVulnerabilityDetails", {}).get("vulnerabilityId")
                    if cve:
                        cves.append(cve)
                    # print(cve)
                return cves


            def all_instances_details_from_inspector(inspector):
                instances = list()
                result = list()
                findings = inspector.list_finding_aggregations(
                    aggregationType="AWS_EC2_INSTANCE",
                    # aggregationRequest='AWS_EC2_INSTANCE',
                )
                result.extend(findings["responses"])
                next_token = findings.get('nextToken')
                while next_token:
                    findings = inspector.list_finding_aggregations(
                        aggregationType="AWS_EC2_INSTANCE",
                        # aggregationRequest='AWS_EC2_INSTANCE',
                        nextToken=next_token,
                    )
                    result.extend(findings["responses"])
                    next_token = findings.get('nextToken')

                for finding in result:
                    instance_details = {
                        "id": finding["ec2InstanceAggregation"]["instanceId"],
                        "name": finding["ec2InstanceAggregation"].get("instanceTags", {}).get("Name"),
                    }
                    instances.append(instance_details)
                print("Found total instances =", len(instances))
                return instances


            def find_rule_for_cve(all_rules, cve):
                return [rule for rule in all_rules if cve in (rule.to_dict()["cve"] or [])]


            def send_email(sender, recipients, subject, body, html_body):
                print("sending email confirmation...")
                # The character encoding for the email.
                CHARSET = "UTF-8"

                # Create a new SES resource and specify a region.
                client = boto3.client("ses", region_name=AWS_REGION)

                # Try to send the email.
                try:
                    # Provide the contents of the email.
                    response = client.send_email(
                        Destination={
                            "ToAddresses": recipients,
                        },
                        Message={
                            "Body": {
                                "Html": {
                                    "Charset": CHARSET,
                                    "Data": html_body,
                                },
                                "Text": {
                                    "Charset": CHARSET,
                                    "Data": body,
                                },
                            },
                            "Subject": {
                                "Charset": CHARSET,
                                "Data": subject,
                            },
                        },
                        Source=sender,
                        # If you are not using a configuration set, comment or delete the
                        # following line
                        # ConfigurationSetName=CONFIGURATION_SET,
                    )
                # Display an error if something goes wrong.
                except ClientError as e:
                    print(e.response["Error"]["Message"])
                else:
                    print("Email sent! Message ID:"),
                    print(response["MessageId"])


            def lambda_handler(event, context):
                # get secret
                secrets = boto3.client('secretsmanager').get_secret_value(SecretId=C1_API_KEY)
                sm_data = json.loads(secrets["SecretString"])
                new_api_format = sm_data["ApiKey"]
                conf, api_version = ds_config_and_version(new_api_format)

                add_rules_output = dict()
                inspector = boto3.client("inspector2", region_name=AWS_REGION)

                ips_rules = list_all_ips_rules(conf=conf, api_version=api_version)
                ips_rules_info = dict()
                for ipr in ips_rules:
                    if ipr.cve:
                        ips_rules_info[ipr.id] = {"cves": ipr.cve, "name": ipr.name}

                inspector = boto3.client("inspector2")
                all_instance_details = all_instances_details_from_inspector(inspector)
                for instance_details in all_instance_details:
                    instance_id = instance_details["id"]
                    instance_name = instance_details["name"]

                    vul_from_instance = vulnerabilities_from_instance(
                        conf, api_version, instance_id, ips_rules_info
                    )
                    print(instance_name, instance_id)
                    cves = cves_from_instance(instance_id, inspector)
                    print("deep security", vul_from_instance)
                    print("inspector", cves)
                    for cve in cves:
                        print(f"finding rule for {cve}")
                        rules = [
                            rule_id
                            for rule_id in ips_rules_info
                            if cve in ips_rules_info[rule_id]["cves"]
                        ]
                        if rules:
                            computer = computer_from_instance_id(
                                configuration=conf,
                                api_version=api_version,
                                instance_id=instance_id,
                            )
                            print(f"adding rules - {rules} to computer")
                            for rule_id in rules:
                                if (
                                    computer.intrusion_prevention.rule_ids
                                    and rule_id in computer.intrusion_prevention.rule_ids
                                ):
                                    print(
                                        f'rule "{rule_id}" already assigned to computer, skipping...'
                                    )
                                else:
                                    add_rules_to_computer(conf, api_version, computer.id, rule_id)
                                    add_rules_output[instance_id] = ips_rules_info[rule_id]["name"]
                print(f"added rules to {len(add_rules_output)} computer(s)")
                print(add_rules_output)

                if add_rules_output:
                    # Specify a configuration set. If you do not want to use a configuration
                    # set, comment the following variable, and the
                    # ConfigurationSetName=CONFIGURATION_SET argument below.

                    # The subject line for the email.
                    subject = "Added Rules To Instances"
                    # The email body for recipients with non-HTML email clients.
                    body = f"Added rules:\r\n" "{add_rules_output}\r\n"

                    added_rules_table_html = '<table border="1">' + "\n"
                    # write headers
                    added_rules_table_html += "</tr>" + "\n"
                    for col in ["instance id", "rule name"]:
                        added_rules_table_html += f"<th>{col}</th>" + "\n"
                    added_rules_table_html += "</tr>" + "\n"
                    # write rows
                    for instance_id in add_rules_output:
                        added_rules_table_html += "<tr>" + "\n"
                        added_rules_table_html += f"<td>{instance_id}</td>" + "\n"
                        added_rules_table_html += f"<td>{add_rules_output[instance_id]}</td>" + "\n"
                        added_rules_table_html += "</tr>" + "\n"
                    added_rules_table_html += "</table>"

                    # The HTML body of the email.
                    body_html = f"""<html>
                    <head></head>
                    <body>
                    <h1>Added rules</h1>
                    {added_rules_table_html}
                    </body>
                    </html>
                    """

                    send_email(SENDER, RECIPIENTS.split(","), subject, body, body_html)

                lambda_client = boto3.client('lambda')
                lambda_payload = b''
                lambda_client.invoke(FunctionName=VULNERABILITY_REPORT_LAMBDA_FUNCTION, 
                                        InvocationType='Event',
                                        Payload=lambda_payload)
                print('triggered vulnerability report lambda function')

            ######################################## Uncomment the following if you running on your local machine
            #lambda_handler(None, None)



      FunctionName: "AutoAssignIpsRuleLambda"
      Handler: "index.lambda_handler"
      Layers:
        - !Ref PythonPackageLayer
      Runtime: python3.9
      Timeout: 600
      Role: !GetAtt LambdaRole.Arn

  ScheduledRule: 
    Type: AWS::Events::Rule
    Properties: 
      Description: "ScheduledRule"
      ScheduleExpression: !Sub ${CronSchedule} 
      State: "ENABLED"
      Targets: 
        - 
          Arn: 
            Fn::GetAtt: 
              - "AutoAssignIpsRuleLambda"
              - "Arn"
          Id: "TargetFunctionV1"
  
  PermissionForEventsToInvokeLambda: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Ref "AutoAssignIpsRuleLambda"
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: 
        Fn::GetAtt: 
          - "ScheduledRule"
          - "Arn"
 
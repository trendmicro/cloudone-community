Parameters:
  Region:
    Type: String
    Description: Please enter the region in which the lambda will be executed
    AllowedValues:
      - us-east-1
      - us-east-2	
      - us-east-1	
      - us-west-1	
      - us-west-2
      - af-south-1
      - ap-east-1
      - ap-southeast-3
      - ap-south-1
      - ap-northeast-3
      - ap-northeast-2
      - ap-southeast-1
      - ap-southeast-2
      - ap-northeast-1
      - ca-central-1
      - eu-central-1
      - eu-west-1
      - eu-west-2
      - eu-south-1
      - eu-west-3
      - eu-north-1
      - me-south-1
      - me-central-1
      - sa-east-1
  ApiKey:
    Type: String
    Description: Please enter your Cloud One Workload Security API Key
  EmailSender:
    Type: String
    Description: Email id to be used for sending report
  EmailRecipients:
    Type: String
    Description: Comma separated email ids for recieving report
  WorkloadSecurityHost:
    Type: String
    Description: Enter your Workload Security Host 
    Default: https://workload.us-1.cloudone.trendmicro.com/api
    AllowedValues:
      - https://workload.trend-us-1.cloudone.trendmicro.com/api
      - https://workload.us-1.cloudone.trendmicro.com/api
      - https://workload.in-1.cloudone.trendmicro.com/api
      - https://workload.gb-1.cloudone.trendmicro.com/api
      - https://workload.jp-1.cloudone.trendmicro.com/api
      - https://workload.de-1.cloudone.trendmicro.com/api
      - https://workload.au-1.cloudone.trendmicro.com/api
      - https://workload.ca-1.cloudone.trendmicro.com/api
      - https://workload.sg-1.cloudone.trendmicro.com/api
  CronSchedule:
    Type: String
  Description: Schedule the time you would like the lambda function to run in the cron format (Default is every 3 min after deployment)
  Default: cron(0/3 * ? * * *)

Resources:
  LambdaLayer2:
    Type: "AWS::Lambda::LayerVersion"
    Properties:
      CompatibleRuntimes:
        - python3.9
      Content:
        S3Bucket: vulnerabilitytestbucket
        S3Key: "python.zip"
      LayerName: "DSlayer"
  
  LambdaRoleForRuleAssignment: 
    Type: "AWS::IAM::Role"
    Properties: 
      AssumeRolePolicyDocument: 
        Version: "2012-10-17"
        Statement: 
          - Effect: "Allow"
            Principal: 
              Service: 
                - "lambda.amazonaws.com" 
            Action: 
              - "sts:AssumeRole"  
      ManagedPolicyArns:
          - arn:aws:iam::aws:policy/AmazonVPCCrossAccountNetworkInterfaceOperations
          # - !Ref ManagedPolicyforlambda 
          - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
          - arn:aws:iam::aws:policy/AmazonInspector2ReadOnlyAccess
          - arn:aws:iam::aws:policy/AmazonSESFullAccess

  LambdaLayerParameterForAutoAssignment:
    Type: AWS::SSM::Parameter
    Properties:
      Name: lambda_layer_for_auto_assign_ips_rule
      Type: String
      Value: "NA"

  LambdaFunctionForAutoAssignment:
    Type: "AWS::Lambda::Function"
    DependsOn:
      - "LambdaLayerParameterForAutoAssignment"
    Properties:
      Environment:
        Variables:
          region: !Ref Region
          apikey: !Ref ApiKey
          sender: !Ref EmailSender
          recipients: !Ref EmailRecipients
          host: !Ref WorkloadSecurityHost
      Code:
        ZipFile: |
            import sys, warnings
            from typing import List
            from pprint import pprint
            import boto3
            from botocore.exceptions import ClientError
            import os
            import deepsecurity as ds
            from deepsecurity.rest import ApiException
            from deepsecurity.models.intrusion_prevention_rule import IntrusionPreventionRule
            from deepsecurity.models.intrusion_prevention_rules import IntrusionPreventionRules
            from email.mime.multipart import MIMEMultipart
            from email.mime.text import MIMEText
            from email.mime.application import MIMEApplication

            #### leave the following uncomment for Cloud Formation Template deployment.. followings are parameters that need to be input##
            API_VERSION = "v1"
            AWS_REGION = os.environ.get("region")
            SENDER = os.environ.get("sender")
            RECIPIENTS = os.environ.get("recipients")
            API_KEY = os.environ.get("apikey")
            HOST = os.environ.get('host')


            def ds_config_and_version():
                # Setup
                if not sys.warnoptions:
                    warnings.simplefilter("ignore")
                conf = ds.Configuration()
                conf.host = HOST
                conf.api_key["Authorization"] = f"ApiKey {API_KEY}"
                return conf, API_VERSION


            def list_all_ips_rules(conf, api_version) -> List[IntrusionPreventionRule]:
                api_client = ds.ApiClient(configuration=conf)
                all_ips_rules: List[IntrusionPreventionRule] = list()

                ips = ds.IntrusionPreventionRulesApi(api_client=api_client)

                search_criteria = ds.SearchCriteria(id_value=0, id_test="greater-than")
                search_filter = ds.SearchFilter(max_items=5000, search_criteria=[search_criteria])

                while True:
                    rules: IntrusionPreventionRules = ips.search_intrusion_prevention_rules(
                        api_version=api_version, search_filter=search_filter, async_req=False
                    )

                    ips_rules: List[IntrusionPreventionRule] = rules.intrusion_prevention_rules
                    if not ips_rules:
                        break

                    all_ips_rules.extend(ips_rules)
                    search_criteria.id_value = ips_rules[-1].id

                return all_ips_rules


            def computer_from_instance_id(configuration, api_version, instance_id):
                # Set search criteria
                search_criteria = ds.SearchCriteria()
                search_criteria.field_name = "ec2VirtualMachineSummary/instanceID"
                search_criteria.string_test = "equal"
                search_criteria.string_value = instance_id

                # Create a search filter with maximum returned items
                search_filter = ds.SearchFilter()
                search_filter.search_criteria = [search_criteria]

                expand = ds.Expand(ds.Expand.intrusion_prevention)
                expand.add(ds.Expand.ec2_virtual_machine_summary)

                # Perform the search and do work on the results
                computers_api = ds.ComputersApi(ds.ApiClient(configuration))

                computers = computers_api.search_computers(
                    api_version, search_filter=search_filter, expand=expand.list(), overrides=False
                )
                num_found = len(computers.computers)

                if num_found == 0:
                    raise Exception(f"No computers found for instance id: {instance_id}")

                for computer in computers.computers:
                    return computer


            # def vulnerabilities_from_instance(configuration, api_version, instance_id):
            def vulnerabilities_from_instance(
                configuration, api_version, instance_id, all_rules_dict
            ):
                # Set search criteria
                search_criteria = ds.SearchCriteria()
                search_criteria.field_name = "ec2VirtualMachineSummary/instanceID"
                search_criteria.string_test = "equal"
                search_criteria.string_value = instance_id

                # Create a search filter with maximum returned items
                search_filter = ds.SearchFilter()
                search_filter.search_criteria = [search_criteria]

                expand = ds.Expand(ds.Expand.intrusion_prevention)
                expand.add(ds.Expand.ec2_virtual_machine_summary)

                # Perform the search and do work on the results
                computers_api = ds.ComputersApi(ds.ApiClient(configuration))
                rows = []

                computers = computers_api.search_computers(
                    api_version, search_filter=search_filter, expand=expand.list(), overrides=False
                )
                num_found = len(computers.computers)

                if num_found == 0:
                    raise Exception(f"No computers found for instance id: {instance_id}")

                for computer in computers.computers:
                    # print('ips', computer.intrusion_prevention)
                    # print(computer.host_name)
                    print(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>   id", computer.id)
                    if computer.intrusion_prevention.rule_ids:
                        for ipr_id in computer.intrusion_prevention.rule_ids:
                            print(">>>>>>>>> checking rule id:", ipr_id)
                            cves = all_rules_dict.get(ipr_id)
                            if cves:
                                for cve in cves:
                                    rows.append(cve)

                    else:
                        print(f"instance has no ips - {instance_id}")
                return rows


            def add_rules_to_computer(configuration, api_version, computer_id, rule_ids):
                # Initialization
                # Set Any Required Values
                api_instance = ds.ComputerIntrusionPreventionRuleAssignmentsRecommendationsApi(
                    ds.ApiClient(configuration)
                )
                intrusion_prevention_rule_ids = ds.RuleIDs(rule_ids=rule_ids)
                overrides = False

                try:
                    api_response = api_instance.add_intrusion_prevention_rule_ids_to_computer(
                        computer_id,
                        api_version,
                        intrusion_prevention_rule_ids=intrusion_prevention_rule_ids,
                        overrides=overrides,
                    )
                    pprint(api_response)
                except ApiException as e:
                    print(
                        "An exception occurred when calling ComputerIntrusionPreventionRuleAssignmentsRecommendationsApi.add_intrusion_prevention_rule_ids_to_computer: %s\n"
                        % e
                    )


            def cves_from_instance(instance_id):
                cves = list()
                result = list()
                inspector = boto3.client("inspector2", region_name=AWS_REGION)
                # print('instance', instance_id)
                resp = inspector.list_findings(
                    filterCriteria={
                        "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                        "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                    }
                )
                result.extend(resp["findings"])
                next_token = resp.get("nextToken")
                while next_token:
                    resp = inspector.list_findings(
                        filterCriteria={
                            "findingStatus": [{"comparison": "EQUALS", "value": "ACTIVE"}],
                            "resourceId": [{"comparison": "EQUALS", "value": instance_id}],
                        },
                        nextToken=next_token,
                    )
                    result.extend(resp["findings"])
                    next_token = resp.get("nextToken")

                for finding in result:
                    cve = finding.get("packageVulnerabilityDetails", {}).get("vulnerabilityId")
                    if cve:
                        cves.append(cve)
                    # print(cve)
                return cves


            def all_instance_details_from_inspector():
                # TODO: check for next token as max result is 50
                inspector = boto3.client("inspector2", region_name=AWS_REGION)
                instances = list()
                findings = inspector.list_finding_aggregations(
                    aggregationType="AWS_EC2_INSTANCE",
                    # aggregationRequest='AWS_EC2_INSTANCE',
                    maxResults=50,
                )

                for f in findings["responses"]:
                    instance_details = {
                        "id": f["ec2InstanceAggregation"]["instanceId"],
                        "name": f["ec2InstanceAggregation"].get("instanceTags", {}).get("Name"),
                    }
                    instances.append(instance_details)
                print("Found total instances =", len(instances))
                return instances


            def find_rule_for_cve(all_rules, cve):
                return [rule for rule in all_rules if cve in (rule.to_dict()["cve"] or [])]


            def send_email(sender, recipients, subject, body, html_body):
                print("sending email confirmation...")
                # The character encoding for the email.
                CHARSET = "UTF-8"

                # Create a new SES resource and specify a region.
                client = boto3.client("ses", region_name=AWS_REGION)

                # Try to send the email.
                try:
                    # Provide the contents of the email.
                    response = client.send_email(
                        Destination={
                            "ToAddresses": recipients,
                        },
                        Message={
                            "Body": {
                                "Html": {
                                    "Charset": CHARSET,
                                    "Data": html_body,
                                },
                                "Text": {
                                    "Charset": CHARSET,
                                    "Data": body,
                                },
                            },
                            "Subject": {
                                "Charset": CHARSET,
                                "Data": subject,
                            },
                        },
                        Source=sender,
                        # If you are not using a configuration set, comment or delete the
                        # following line
                        # ConfigurationSetName=CONFIGURATION_SET,
                    )
                # Display an error if something goes wrong.
                except ClientError as e:
                    print(e.response["Error"]["Message"])
                else:
                    print("Email sent! Message ID:"),
                    print(response["MessageId"])


            def lambda_handler(event, context):
                add_rules_output = dict()
                conf, api_version = ds_config_and_version()

                ips_rules = list_all_ips_rules(conf=conf, api_version=api_version)
                ips_rules_info = dict()
                for ipr in ips_rules:
                    if ipr.cve:
                        ips_rules_info[ipr.id] = {"cves": ipr.cve, "name": ipr.name}

                all_instance_details = all_instance_details_from_inspector()
                for instance_details in all_instance_details:
                    instance_id = instance_details["id"]
                    instance_name = instance_details["name"]

                    vul_from_instance = vulnerabilities_from_instance(
                        conf, api_version, instance_id, ips_rules_info
                    )
                    print(instance_name, instance_id)
                    cves = cves_from_instance(instance_id)
                    print("deep security", vul_from_instance)
                    print("inspector", cves)
                    for cve in cves:
                        print(f"finding rule for {cve}")
                        rules = [
                            rule_id
                            for rule_id in ips_rules_info
                            if cve in ips_rules_info[rule_id]["cves"]
                        ]
                        if rules:
                            computer = computer_from_instance_id(
                                configuration=conf,
                                api_version=api_version,
                                instance_id=instance_id,
                            )
                            print(f"adding rules - {rules} to computer")
                            for rule_id in rules:
                                if (
                                    computer.intrusion_prevention.rule_ids
                                    and rule_id in computer.intrusion_prevention.rule_ids
                                ):
                                    print(
                                        f'rule "{rule_id}" already assigned to computer, skipping...'
                                    )
                                else:
                                    add_rules_to_computer(conf, api_version, computer.id, rule_id)
                                    add_rules_output[instance_id] = ips_rules_info[rule_id]["name"]
                print(f"added rules to {len(add_rules_output)} computer(s)")
                print(add_rules_output)

                if add_rules_output:
                    # Specify a configuration set. If you do not want to use a configuration
                    # set, comment the following variable, and the
                    # ConfigurationSetName=CONFIGURATION_SET argument below.

                    # The subject line for the email.
                    subject = "Added Rules To Instances"
                    # The email body for recipients with non-HTML email clients.
                    body = f"Added rules:\r\n" "{add_rules_output}\r\n"

                    added_rules_table_html = '<table border="1">' + "\n"
                    # write headers
                    added_rules_table_html += "</tr>" + "\n"
                    for col in ["instance id", "rule name"]:
                        added_rules_table_html += f"<th>{col}</th>" + "\n"
                    added_rules_table_html += "</tr>" + "\n"
                    # write rows
                    for instance_id in add_rules_output:
                        added_rules_table_html += "<tr>" + "\n"
                        added_rules_table_html += f"<td>{instance_id}</td>" + "\n"
                        added_rules_table_html += f"<td>{add_rules_output[instance_id]}</td>" + "\n"
                        added_rules_table_html += "</tr>" + "\n"
                    added_rules_table_html += "</table>"

                    # The HTML body of the email.
                    body_html = f"""<html>
                    <head></head>
                    <body>
                    <h1>Added rules</h1>
                    {added_rules_table_html}
                    </body>
                    </html>
                    """

                    send_email(SENDER, RECIPIENTS.split(","), subject, body, body_html)

            ######################################## Uncomment the following if you running on your local machine
            # lambda_handler(None, None)

      FunctionName: "LambdaFunctionForAutoAssignment"
      Handler: "index.lambda_handler"
      Layers:
        - !Ref LambdaLayer2
      Runtime: python3.9
      Timeout: 300
      Role: !GetAtt LambdaRoleForRuleAssignment.Arn
  ScheduledRule: 
    Type: AWS::Events::Rule
    Properties: 
      Description: "ScheduledRule"
      ScheduleExpression: !Sub ${CronSchedule} 
      State: "ENABLED"
      Targets: 
        - 
          Arn: 
            Fn::GetAtt: 
              - "LambdaFunctionForAutoAssignment"
              - "Arn"
          Id: "TargetFunctionV1"
  PermissionForEventsToInvokeLambda: 
    Type: AWS::Lambda::Permission
    Properties: 
      FunctionName: !Ref "LambdaFunctionForAutoAssignment"
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: 
        Fn::GetAtt: 
          - "ScheduledRule"
          - "Arn"